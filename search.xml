<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python“可迭代”漫谈</title>
    <url>/200225/</url>
    <content><![CDATA[<!-- build time:Mon Feb 24 2020 21:47:46 GMT+0800 (中国标准时间) --><p><img data-src="https://media-1257181248.cos.ap-chengdu.myqcloud.com/blog/200225.jpg" alt="python"><br>深入探索Python可迭代对象，兼谈迭代器。</p><a id="more"></a><h2 id="引子：iterable——terrible"><a href="#引子：iterable——terrible" class="headerlink" title="引子：iterable——terrible!"></a>引子：iterable——terrible!</h2><p>昨晚，在夜深人静之时，为了试验某个想法，我郑重地进入了Python交互环境。为了实现这个想法，我需要将<code>int</code>值<code>3</code>加入到列表<code>n</code>中，这本是很常规的操作，但或许是太过亢奋的缘故，我竟写下了这样的一句：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n[len(n):]=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>不出你所料，我得到了这样的结果：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br></pre></td></tr></table></figure><p>我一拍脑门，不由得想扇自己两巴掌，赶紧重新写：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n[len(n):]=[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>这下总算好了。</p><p>然而，后来我越想越气不过，凭什么<code>int</code>类型不是可迭代对象！凭什么<code>int</code>就要比<code>list</code>和<code>str</code>低一等！</p><p>于是，抱着万物平等的第一信念和好好学习天天向上的第二信念，我开始了探索之旅。</p><p>PS：本文中所涉及代码的运行环境均为Python3.8.1</p><h2 id="找Python讨说法"><a href="#找Python讨说法" class="headerlink" title="找Python讨说法"></a>找Python讨说法</h2><h3 id="在战略上藐视敌人"><a href="#在战略上藐视敌人" class="headerlink" title="在战略上藐视敌人"></a>在战略上藐视敌人</h3><p>还记得你上初中时听到一群高中生谈论导函数、极限时你瑟瑟发抖的样子吗？等到你自己上了高中，才发现真相：一切高端词汇都是纸老虎。</p><p>秉承毛泽东同志的精神，我们要看清敌人的本质，做到在战略上藐视敌人。让我们先来看看到底什么是迭代。</p><p>这只老虎表面上是这样的：</p><div class="note success"><p>迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。<br>——摘自Wikipedia</p></div><p>我及其佩服编写这个wiki页面的朋友，居然能如此简洁而精准却不明了地解释一个概念，像极了某些教科书。</p><p>现在我们不仅没弄清可迭代对象，就连对迭代本身也开始感到糊里糊涂了。</p><p>然而，所谓真老虎也怕火炼，纸老虎一点就着，下面我们就试着揭开这只老虎的面纱。</p><h3 id="可疑对象"><a href="#可疑对象" class="headerlink" title="可疑对象"></a>可疑对象</h3><p>从哪儿跌倒就要从哪儿爬起来，既然是在Python交互环境跌倒，我就必须要向它讨个说法了。</p><p>古人说得好：“知己知彼，百战不殆。”我们先来探一探<code>list</code>和<code>str</code>的虚实：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(str)</span><br></pre></td></tr></table></figure><p><code>dir()</code>一出，一切魑魅魍魉再也无所遁形。</p><p>于是，在这形形色色的函数中，我们发现了一个可疑对象——<code>__iter__</code>：<code>str</code>和<code>list</code>中都包含这个方法，而且此子长得和iterable极其相似！</p><p>我们再来看看<code>int</code>，利用<code>hasattr()</code>判断<code>int</code>中有无<code>__iter__</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(int,<span class="string">"__iter__"</span>)</span><br></pre></td></tr></table></figure><p>果然，我们得到了一个无情的<code>False</code>。</p><h3 id="深入敌后"><a href="#深入敌后" class="headerlink" title="深入敌后"></a>深入敌后</h3><p>我们似乎已经找到了一个关键人物<code>__iter__</code>，那么，这位仁兄究竟在整个事件中扮演了怎样的角色呢？我们请出问题终结者<code>help</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(str.__iter__)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(list.__iter__)</span><br></pre></td></tr></table></figure><p>我们得到了相同的结果，在<code>str</code>和<code>list</code>中，<code>__iter__</code>的作用均是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Help on wrapper_descriptor:</span><br><span class="line"></span><br><span class="line">__iter__(self, /)</span><br><span class="line">    Implement iter(self).</span><br></pre></td></tr></table></figure><p>Implement iter(self)：实现iter(self)！？</p><p>那我们就来看看这个<code>iter()</code>到底是怎么回事：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>n=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(n)</span><br></pre></td></tr></table></figure><p>于是，我们得到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;list_iterator object at 0x7f5844014a60&gt;</span><br></pre></td></tr></table></figure><p>list_iterator：我们获得了一个列表迭代器！</p><p>使用<code>help</code>，我们看看<code>iter</code>到底做了什么：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Help on built-in <span class="keyword">function</span> iter <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">iter(...)</span><br><span class="line">    iter(iterable) -&gt; iterator</span><br><span class="line">    iter(callable, sentinel) -&gt; iterator</span><br><span class="line">    </span><br><span class="line">    Get an iterator from an object.  In the first form, the argument must</span><br><span class="line">    supply its own iterator, or be a sequence.</span><br><span class="line">    In the second form, the callable is called until it returns the sentinel.</span><br></pre></td></tr></table></figure><p>是的，他可以帮助我们从对象获得一个迭代器。</p><p>那么，我们来看看这个新出现的名为迭代器的东西有什么非凡之处：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m=iter(n)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(m)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list_iterator</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>现在，我们得到了迭代器<code>m</code>，我们十分谨慎地查阅了其类型，确定它是一个迭代器。</p><h3 id="蓦然回首"><a href="#蓦然回首" class="headerlink" title="蓦然回首"></a>蓦然回首</h3><p>现在，我们再次请出<code>dir()</code>，分别看看<code>n</code>和<code>m</code>背后都有些什么：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(n)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(m)</span><br></pre></td></tr></table></figure><p><code>n</code>作为一个列表，与<code>list</code>中包含的东西当然并无不同，而<code>m</code>则让我们大开眼界，里面竟然有个不同寻常的东西：除了<code>__iter__</code>之外，它还有一个<code>__next__</code>。</p><p>与<code>__iter__</code>类似，使用<code>next()</code>可以调用<code>__next__</code>，我们多次运行<code>next(m)</code>，得到：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(m)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(m)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(m)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(m)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(m)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><p>真是一个惊喜！我们依次获得了<code>n</code>中的每个元素！</p><p>同样，使用<code>help</code>，看看<code>next</code>做了什么工作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Help on built-in <span class="keyword">function</span> next <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">next(...)</span><br><span class="line">    next(iterator[, default])</span><br><span class="line">    </span><br><span class="line">    Return the next item from the iterator. If default is given and the iterator</span><br><span class="line">    is exhausted, it is returned instead of raising StopIteration.</span><br></pre></td></tr></table></figure><p><code>next</code>能够返回迭代器的下一个元素。</p><h3 id="绝杀"><a href="#绝杀" class="headerlink" title="绝杀"></a>绝杀</h3><p>这时，我们心中已经隐隐有了一些猜想，现在我们梳理一下在上述过程中我们得到的一些信息：</p><ul><li><code>str</code>、<code>list</code>为可迭代对象，他们能实现<code>__iter__()</code>方法</li><li><code>int</code>不是可迭代对象，不能实现<code>__iter__()</code>方法</li><li><code>iter()</code>函数可以调用<code>__iter__</code>方法</li><li>我们获得的迭代器也实现了<code>__iter__()</code>，并且还实现了<code>__next__()</code></li><li><code>next()</code>可以输出迭代器的下一个元素</li></ul><p>大胆猜测：迭代器也是可迭代对象，能实现<code>__iter__()</code>方法的即为可迭代对象，兼有<code>__next__()</code>就是迭代器。</p><p>求助Google（它终于上场了）：我们的猜想正确。</p><p>还记得我们摘自Wikipedia的那段话吗？</p><blockquote><p>迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。</p></blockquote><p>还记得<code>iter</code>的作用吗？</p><blockquote><p>Get an iterator from an object.</p></blockquote><p><code>next</code>呢？</p><blockquote><p>Return the next item from the iterator.</p></blockquote><p>我们这下可不能怪Python了，<code>int</code>确实从骨子里就不是可迭代对象：<code>list</code>、<code>str</code>等都可以看做是一个序列（即使有时它们只包含了一个元素），我们能按照一定顺序调用其中的元素（用<code>iter</code>转迭代器，用<code>next</code>返回它的值），而<code>int</code>不过是一个数值，当然不同于它们。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，我们通过一个不起眼的小错误，借题发挥，终于弄清了可迭代对象和迭代器的关系。</p><p>不得不感叹：人生苦短，我玩蟒蛇。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>一位机器人的“终极哲学之问”</title>
    <url>/200224/</url>
    <content><![CDATA[<!-- build time:Mon Feb 24 2020 20:05:32 GMT+0800 (中国标准时间) --><p><img data-src="https://media-1257181248.cos.ap-chengdu.myqcloud.com/blog/200224.jpg" alt="AI"></p><blockquote><p>转自中国科学院-李志天<br>图片来源:aiimooc</p></blockquote><a id="more"></a><h2 id="引子：哲学之问"><a href="#引子：哲学之问" class="headerlink" title="引子：哲学之问"></a>引子：哲学之问</h2><div class="note success"><p>一位迷路人的内心哲学之问：</p><ul><li>我在哪儿？</li><li>我从哪里来？</li><li>又往何处去？</li></ul></div><h2 id="什么是SLAM？"><a href="#什么是SLAM？" class="headerlink" title="什么是SLAM？"></a>什么是SLAM？</h2><p>家里新添置了一台扫地机器人，老妈对它啧啧称奇：一个盘子大小的机器，刚进门就直接开工，简直是任劳任怨。</p><p>那是什么技术让扫地机器人聪明的智商占领了高地呢？翻看扫地机器人的产品介绍，你就会发现一个众多扫地机器人都在使用的名词——“同时定位与建图（Simultaneous Localization and Mapping，SLAM）技术”。</p><p>SLAM是什么？首先让从我们“穿越”成为一台扫地机器人说起。作为一台扫地机器人，进入一个陌生空间后，如果想要完成自动扫地任务，你需要完成哪些工作呢？</p><ul><li>我是谁，我在哪儿？<ul><li>如何快速实现定位，了解自己在环境中的相对位置；</li></ul></li><li>我从哪里来，周围有什么？<ul><li>如何实时构建周围环境的地图，感知到哪里有障碍物，哪里有墙？依托地图信息的定位才有意义；</li></ul></li><li>我要到哪去，该怎么去？<ul><li>有了地图，有了位置，如何实现路径规划，能够不撞墙、不走重复路、也不遗漏每个角落？</li></ul></li></ul><p><img data-src="https://media-1257181248.cos.ap-chengdu.myqcloud.com/blog/200224/1.gif" alt="扫地机器人"></p><p>以上三个问题就是一台扫地机器人用SLAM这个工具要解决的“终极哲学问题”</p><blockquote><p>严格来说，SLAM仅仅包含前两个问题，一些AR应用场景也没有包含路径规划问题，此处我们以扫地机器人引入SLAM问题，一并来讲。</p></blockquote><h2 id="SLAM如何解答“哲学之问”"><a href="#SLAM如何解答“哲学之问”" class="headerlink" title="SLAM如何解答“哲学之问”"></a>SLAM如何解答“哲学之问”</h2><p>SLAM技术的精髓，就在于“S”——Simultaneous，中文意思就是“一边……一边……”，一边获取自身位置，解答“我在哪儿”的问题，一边构建地图，解答“我从哪里来，周围有什么”的问题。为了更好的让大家理解这个“S”的含义，我们话分两边，首先来看看SLAM技术的前世今生：</p><p>SLAM的技术思想最早还要追溯到军事领域中的潜艇定位。不同于水面舰艇可以轻松通过GPS、目视观察等方式进行导航定位，潜艇在执行任务时要下潜至没有阳光的深海活动（这个很好理解，浮在水面或者浅水区那就失去了潜艇的意义~），难以通过传统方式进行直接定位导航，因此为了能正常开展任务，潜艇大多应用INS(惯性导航)和APS(水声导航)联合定位，加上航迹测绘和海图资料推算大致的舰艇位置，像这样定位加测绘制图的过程就是SLAM技术思想的雏形。</p><p>就像潜艇一样，机器人也不能总依赖GPS，尤其是应用在室内场景下的扫地机器人——GPS在室外都是几米的精度，依赖GPS无法让扫地机器人既能安全躲避茶几腿，又能打扫沙发底。依托SLAM技术，它们可以自行观察和绘制周围环境，通过传感器数据校准来构建导航地图，进而了解自己身处何方，应该去哪里扫地或者回角落充电。我们可以总结一下SLAM简单的技术思路：在没有先验知识的情况下，通过传感器获取周边环境信息，快速实时构建出环境地图，同时解算自身位置，在此基础上完成路径规划等后续任务。听起来是不是很简单？但其实SLAM是一个复杂的多阶段任务，包括通过传感器采集实际环境中的各类型原始数据（激光扫描数据、视觉信息数据等），通过视觉里程计计算不同时刻间移动目标相对位置估算（包括特征匹配、直接配准等），经由后端模块优化视觉里程计带来的累积误差（传统滤波算法、图优化算法等），最终经由建图模块生成地图（当然通常还需要配有回环检测用于消除空间累积误差等），从而实现建图与定位的目的。</p><p><img data-src="https://media-1257181248.cos.ap-chengdu.myqcloud.com/blog/200224/3.webp" alt="SLAM的基本思想"></p><p><img data-src="https://media-1257181248.cos.ap-chengdu.myqcloud.com/blog/200224/2.gif" alt="一个视觉SLAM运行实例"></p><h2 id="SLAM的今天与未来"><a href="#SLAM的今天与未来" class="headerlink" title="SLAM的今天与未来"></a>SLAM的今天与未来</h2><p>近年来，随着智能技术与硬件算力的极大发展，SLAM技术正处于极快的发展时期。它赋予机器人和其他智能体前所未有的行动能力，已成为人工智能实现的“双腿”，随着智能机器人、自动驾驶、AR/VR等应用走进了千家万户。按所使用的传感器的不同，我们可以把SLAM分为两大类，一类是使用激光雷达的激光SLAM，一类是使用视觉摄像头的视觉SLAM。其中，激光雷达测量更快更准，信息更丰富，测距比较准确，误差模型简单，在强光直射以外的环境中运行稳定，机器人的路径规划和导航也更为直观，目前被广泛应用于自动驾驶领域，落地产品更为成熟丰富。但是激光雷达价格昂贵，极大地限制了其应用；</p><p>视觉SLAM的优点是利用所观察到环境中丰富纹理信息来进行处理，可以区分激光雷达无法分辨的物体（例如两块同样大小但内容不同的广告牌）。这带来了重定位、场景分类上无可比拟的巨大优势。同时，视觉信息可以较为容易的被用来跟踪和预测场景中的动态目标，如行人、车辆等，这对于在复杂动态场景中的应用是至关重要的。因此，目前SLAM应用也在往多源融合、广泛感知等方向逐渐发展。</p><p>相信在未来的某天，我们身边的机器人、乘坐的汽车、使用的AR设备都无需再困惑于“终极哲学之问”，都拥有一颗真正的智慧大脑，实现真正的自主行动，帮助我们人类走进更为便捷、智能的未来时代。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>科技</tag>
        <tag>智能</tag>
        <tag>AI</tag>
        <tag>SLAM</tag>
      </tags>
  </entry>
  <entry>
    <title>多于三万六千五</title>
    <url>/200215/</url>
    <content><![CDATA[<!-- build time:Mon Feb 24 2020 20:05:32 GMT+0800 (中国标准时间) --><p><img data-src="https://media-1257181248.cos.ap-chengdu.myqcloud.com/blog/200214.jpg" alt="海子像"><br>——我要致给海子，尤其致他疯狂自由之魂。</p><a id="more"></a><blockquote><p>一阵呜鸣　秋雨提早到了春天 在冬的<br>.　尾声里　第三万六千五百零一块顽石<br>昂起它燎烈的头颅　仇视着雨</p><p>来自田野的土腥味　跨过两条钢轨<br>携带着烧焦的尸骨　流浪汉<br>从北走到北　看到<br>支离破碎的髌骨　一颗火红的心</p><p>用你干枯的指头　抹去苍茫<br>用你苍茫的嘴唇　吻向春风<br>冬的好兄弟　春<br>.　迟来了<br>高原上　一只天鹅聆听圣洁佛语</p><p>麦苗属于你　还有途经戈壁的小路<br>.　属于你　大地的儿子<br>你说阳光充足、灿烂、健康</p><p>我与你偶遇　在前往大山的路上<br>你提着一壶血　自己的<br>叫我看红色的月亮　近在咫尺</p><p>这时　一只犍牛倒在北方的田埂上</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>有感</tag>
      </tags>
  </entry>
</search>
